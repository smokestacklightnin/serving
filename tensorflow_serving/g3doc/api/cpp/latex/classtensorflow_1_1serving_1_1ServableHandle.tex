\hypertarget{classtensorflow_1_1serving_1_1ServableHandle}{}\doxysection{tensorflow\+::serving\+::Servable\+Handle$<$ T $>$ Class Template Reference}
\label{classtensorflow_1_1serving_1_1ServableHandle}\index{tensorflow::serving::ServableHandle$<$ T $>$@{tensorflow::serving::ServableHandle$<$ T $>$}}


{\ttfamily \#include $<$servable\+\_\+handle.\+h$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classtensorflow_1_1serving_1_1ServableHandle_afa693e4f7cf135262c7f0babfc4d42ec}\label{classtensorflow_1_1serving_1_1ServableHandle_afa693e4f7cf135262c7f0babfc4d42ec}} 
\mbox{\hyperlink{classtensorflow_1_1serving_1_1ServableHandle_afa693e4f7cf135262c7f0babfc4d42ec}{Servable\+Handle}} ()=default
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{classtensorflow_1_1serving_1_1ServableHandle}{Servable\+Handle}} is null by default. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classtensorflow_1_1serving_1_1ServableHandle_a0aaec0c528e775316387d8265fb7badf}\label{classtensorflow_1_1serving_1_1ServableHandle_a0aaec0c528e775316387d8265fb7badf}} 
const \mbox{\hyperlink{structtensorflow_1_1serving_1_1ServableId}{Servable\+Id}} \& {\bfseries id} () const
\item 
\mbox{\Hypertarget{classtensorflow_1_1serving_1_1ServableHandle_a9ef846b5c9d09b1d02f9d5bebffbb661}\label{classtensorflow_1_1serving_1_1ServableHandle_a9ef846b5c9d09b1d02f9d5bebffbb661}} 
T \& {\bfseries operator$\ast$} () const
\item 
\mbox{\Hypertarget{classtensorflow_1_1serving_1_1ServableHandle_aabd3a483afc416f8ba57aec5d1357b01}\label{classtensorflow_1_1serving_1_1ServableHandle_aabd3a483afc416f8ba57aec5d1357b01}} 
T $\ast$ {\bfseries operator-\/$>$} () const
\item 
\mbox{\Hypertarget{classtensorflow_1_1serving_1_1ServableHandle_aefc9d99be0d24dbb02668578fa2fdef6}\label{classtensorflow_1_1serving_1_1ServableHandle_aefc9d99be0d24dbb02668578fa2fdef6}} 
T $\ast$ {\bfseries get} () const
\item 
\mbox{\Hypertarget{classtensorflow_1_1serving_1_1ServableHandle_abf4d73c357efead08b91e31583e9c718}\label{classtensorflow_1_1serving_1_1ServableHandle_abf4d73c357efead08b91e31583e9c718}} 
{\bfseries operator bool} () const
\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classtensorflow_1_1serving_1_1ServableHandle_adddd5c43ff870a047aa66db4edf82a7e}\label{classtensorflow_1_1serving_1_1ServableHandle_adddd5c43ff870a047aa66db4edf82a7e}} 
class {\bfseries Manager}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T$>$\newline
class tensorflow\+::serving\+::\+Servable\+Handle$<$ T $>$}

A smart pointer to the underlying servable object T retrieved from the \mbox{\hyperlink{classtensorflow_1_1serving_1_1Loader}{Loader}}. Frontend code gets these handles from the Servable\+Manager. The handle keeps the underlying object alive as long as the handle is alive. The frontend should not hold onto it for a long time, because holding it can delay servable reloading.

The T returned from the handle is generally shared among multiple requests, which means any mutating changes made to T must preserve correctness vis-\/a-\/vis the application logic. Moreover, in the presence of multiple request threads, thread-\/safe usage of T must be ensured.

T is expected to be a value type, and is internally stored as a pointer. Using a pointer type for T will fail to compile, since it would be a mistake to do so in most situations.

Example use\+: \begin{DoxyVerb}// Define or use an existing servable:
class MyServable {
public:
  void MyMethod();
};

// Get your handle from a manager.
ServableHandle<MyServable> handle;
TF_RETURN_IF_ERROR(manager->GetServableHandle(id, &handle));

// Use your handle as a smart-pointer:
handle->MyMethod();
\end{DoxyVerb}
 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
tensorflow\+\_\+serving/core/servable\+\_\+handle.\+h\end{DoxyCompactItemize}
