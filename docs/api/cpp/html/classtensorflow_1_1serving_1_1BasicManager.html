<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: tensorflow::serving::BasicManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tensorflow</b></li><li class="navelem"><b>serving</b></li><li class="navelem"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html">BasicManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtensorflow_1_1serving_1_1BasicManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tensorflow::serving::BasicManager Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="basic__manager_8h_source.html">basic_manager.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tensorflow::serving::BasicManager:</div>
<div class="dyncontent">
<div class="center"><img src="classtensorflow_1_1serving_1_1BasicManager__inherit__graph.png" border="0" usemap="#atensorflow_1_1serving_1_1BasicManager_inherit__map" alt="Inheritance graph"/></div>
<map name="atensorflow_1_1serving_1_1BasicManager_inherit__map" id="atensorflow_1_1serving_1_1BasicManager_inherit__map">
<area shape="rect" title=" " alt="" coords="5,95,151,136"/>
<area shape="rect" href="classtensorflow_1_1serving_1_1Manager.html" title=" " alt="" coords="5,5,151,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for tensorflow::serving::BasicManager:</div>
<div class="dyncontent">
<div class="center"><img src="classtensorflow_1_1serving_1_1BasicManager__coll__graph.png" border="0" usemap="#atensorflow_1_1serving_1_1BasicManager_coll__map" alt="Collaboration graph"/></div>
<map name="atensorflow_1_1serving_1_1BasicManager_coll__map" id="atensorflow_1_1serving_1_1BasicManager_coll__map">
<area shape="rect" title=" " alt="" coords="5,95,151,136"/>
<area shape="rect" href="classtensorflow_1_1serving_1_1Manager.html" title=" " alt="" coords="5,5,151,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorflow_1_1serving_1_1BasicManager_1_1Options.html">Options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abeacf431a3e838da2b1602828f0c0eb2"><td class="memItemLeft" align="right" valign="top"><a id="abeacf431a3e838da2b1602828f0c0eb2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PreLoadHook</b> = std::function&lt; void(const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;)&gt;</td></tr>
<tr class="separator:abeacf431a3e838da2b1602828f0c0eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee7a19d059b362c0702686d981bf5fc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a8ee7a19d059b362c0702686d981bf5fc">DoneCallback</a> = std::function&lt; void(const Status &amp;status)&gt;</td></tr>
<tr class="separator:a8ee7a19d059b362c0702686d981bf5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a492123b8bb97709184ddb57772e3ccf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a492123b8bb97709184ddb57772e3ccf3">~BasicManager</a> () override</td></tr>
<tr class="separator:a492123b8bb97709184ddb57772e3ccf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c004d32952596c1f5759b1cfcc3c639"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a3c004d32952596c1f5759b1cfcc3c639">ListAvailableServableIds</a> () const override</td></tr>
<tr class="separator:a3c004d32952596c1f5759b1cfcc3c639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58907b2d551d693d13b6c979c4bd511"><td class="memItemLeft" align="right" valign="top"><a id="ad58907b2d551d693d13b6c979c4bd511"></a>
Status&#160;</td><td class="memItemRight" valign="bottom"><b>GetUntypedServableHandle</b> (const <a class="el" href="structtensorflow_1_1serving_1_1ServableRequest.html">ServableRequest</a> &amp;request, std::unique_ptr&lt; <a class="el" href="classtensorflow_1_1serving_1_1UntypedServableHandle.html">UntypedServableHandle</a> &gt; *untyped_handle) override</td></tr>
<tr class="separator:ad58907b2d551d693d13b6c979c4bd511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675a065bc2acf6229be899618e190b2b"><td class="memItemLeft" align="right" valign="top"><a id="a675a065bc2acf6229be899618e190b2b"></a>
std::map&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a>, std::unique_ptr&lt; <a class="el" href="classtensorflow_1_1serving_1_1UntypedServableHandle.html">UntypedServableHandle</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetAvailableUntypedServableHandles</b> () const override</td></tr>
<tr class="separator:a675a065bc2acf6229be899618e190b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2759caea67d3d37b9dba31589f9ef1d"><td class="memItemLeft" align="right" valign="top">Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#ac2759caea67d3d37b9dba31589f9ef1d">ManageServable</a> (<a class="el" href="classtensorflow_1_1serving_1_1ServableData.html">ServableData</a>&lt; std::unique_ptr&lt; <a class="el" href="classtensorflow_1_1serving_1_1Loader.html">Loader</a> &gt;&gt; servable)</td></tr>
<tr class="separator:ac2759caea67d3d37b9dba31589f9ef1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72406e3aedfa0084e24f2bd8ec7efdcc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72406e3aedfa0084e24f2bd8ec7efdcc"><td class="memTemplItemLeft" align="right" valign="top">Status&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a72406e3aedfa0084e24f2bd8ec7efdcc">ManageServableWithAdditionalState</a> (<a class="el" href="classtensorflow_1_1serving_1_1ServableData.html">ServableData</a>&lt; std::unique_ptr&lt; <a class="el" href="classtensorflow_1_1serving_1_1Loader.html">Loader</a> &gt;&gt; servable, std::unique_ptr&lt; T &gt; additional_state)</td></tr>
<tr class="separator:a72406e3aedfa0084e24f2bd8ec7efdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3209cd82cbb5eac79bc3238b3c6bec43"><td class="memItemLeft" align="right" valign="top">Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a3209cd82cbb5eac79bc3238b3c6bec43">StopManagingServable</a> (const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;id)</td></tr>
<tr class="separator:a3209cd82cbb5eac79bc3238b3c6bec43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdc3d0ed83559c7d8b3b0092194ead6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#afbdc3d0ed83559c7d8b3b0092194ead6">GetManagedServableNames</a> () const</td></tr>
<tr class="separator:afbdc3d0ed83559c7d8b3b0092194ead6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31716665d8df8451d379363309dac826"><td class="memTemplParams" colspan="2">template&lt;typename T  = std::nullptr_t&gt; </td></tr>
<tr class="memitem:a31716665d8df8451d379363309dac826"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableStateSnapshot.html">ServableStateSnapshot</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a31716665d8df8451d379363309dac826">GetManagedServableStateSnapshots</a> (const string &amp;servable_name) const</td></tr>
<tr class="separator:a31716665d8df8451d379363309dac826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af681f56bbef07ab201f25c0097f73e75"><td class="memTemplParams" colspan="2">template&lt;typename T  = std::nullptr_t&gt; </td></tr>
<tr class="memitem:af681f56bbef07ab201f25c0097f73e75"><td class="memTemplItemLeft" align="right" valign="top">absl::optional&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableStateSnapshot.html">ServableStateSnapshot</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#af681f56bbef07ab201f25c0097f73e75">GetManagedServableStateSnapshot</a> (const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;id)</td></tr>
<tr class="separator:af681f56bbef07ab201f25c0097f73e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dbea960f6d47461dbfca5bfa149335"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99dbea960f6d47461dbfca5bfa149335"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a99dbea960f6d47461dbfca5bfa149335">GetAdditionalServableState</a> (const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;id)</td></tr>
<tr class="separator:a99dbea960f6d47461dbfca5bfa149335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e87e3b0bc3410a78db3439ff0fb9bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a09e87e3b0bc3410a78db3439ff0fb9bb">LoadServable</a> (const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;id, <a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a8ee7a19d059b362c0702686d981bf5fc">DoneCallback</a> done_callback)</td></tr>
<tr class="separator:a09e87e3b0bc3410a78db3439ff0fb9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dca5ec1ecc28421d5ab020beac2ee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a84dca5ec1ecc28421d5ab020beac2ee3">CancelLoadServableRetry</a> (const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;id)</td></tr>
<tr class="separator:a84dca5ec1ecc28421d5ab020beac2ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97af7156e38c29225534bacdeefe9408"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a97af7156e38c29225534bacdeefe9408">UnloadServable</a> (const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;id, <a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a8ee7a19d059b362c0702686d981bf5fc">DoneCallback</a> done_callback)</td></tr>
<tr class="separator:a97af7156e38c29225534bacdeefe9408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classtensorflow_1_1serving_1_1Manager"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classtensorflow_1_1serving_1_1Manager')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classtensorflow_1_1serving_1_1Manager.html">tensorflow::serving::Manager</a></td></tr>
<tr class="memitem:a8ad1c3155120737e5a41776ceeff6aaa inherit pub_methods_classtensorflow_1_1serving_1_1Manager"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ad1c3155120737e5a41776ceeff6aaa inherit pub_methods_classtensorflow_1_1serving_1_1Manager"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a>, <a class="el" href="classtensorflow_1_1serving_1_1ServableHandle.html">ServableHandle</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1Manager.html#a8ad1c3155120737e5a41776ceeff6aaa">GetAvailableServableHandles</a> () const</td></tr>
<tr class="separator:a8ad1c3155120737e5a41776ceeff6aaa inherit pub_methods_classtensorflow_1_1serving_1_1Manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca70babd38f4b416cf27bbf40f8bb093 inherit pub_methods_classtensorflow_1_1serving_1_1Manager"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca70babd38f4b416cf27bbf40f8bb093 inherit pub_methods_classtensorflow_1_1serving_1_1Manager"><td class="memTemplItemLeft" align="right" valign="top">Status&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1Manager.html#aca70babd38f4b416cf27bbf40f8bb093">GetServableHandle</a> (const <a class="el" href="structtensorflow_1_1serving_1_1ServableRequest.html">ServableRequest</a> &amp;request, <a class="el" href="classtensorflow_1_1serving_1_1ServableHandle.html">ServableHandle</a>&lt; T &gt; *const handle)</td></tr>
<tr class="separator:aca70babd38f4b416cf27bbf40f8bb093 inherit pub_methods_classtensorflow_1_1serving_1_1Manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af8f89ab0900a43b12cfbd9b2185fbfde"><td class="memItemLeft" align="right" valign="top"><a id="af8f89ab0900a43b12cfbd9b2185fbfde"></a>
static Status&#160;</td><td class="memItemRight" valign="bottom"><b>Create</b> (<a class="el" href="structtensorflow_1_1serving_1_1BasicManager_1_1Options.html">Options</a> options, std::unique_ptr&lt; <a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html">BasicManager</a> &gt; *manager)</td></tr>
<tr class="separator:af8f89ab0900a43b12cfbd9b2185fbfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2158193bbefd406c1206927ce42fb865"><td class="memItemLeft" align="right" valign="top"><a id="a2158193bbefd406c1206927ce42fb865"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>AspiredVersionsManager</b></td></tr>
<tr class="separator:a2158193bbefd406c1206927ce42fb865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40648d98e6ee77b0bc8b0a272b54410"><td class="memItemLeft" align="right" valign="top"><a id="aa40648d98e6ee77b0bc8b0a272b54410"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>test_util::BasicManagerTestAccess</b></td></tr>
<tr class="separator:aa40648d98e6ee77b0bc8b0a272b54410"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Helps manage the lifecycle of servables including loading, serving and unloading them. The manager accepts servables in the form of Loaders.</p>
<p>We start managing a servable through one of the ManageServable* methods. You can go on to load the servable after this by calling <a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a09e87e3b0bc3410a78db3439ff0fb9bb">LoadServable()</a>. Loading will also make the servable available to serve. Once you decide to unload it, you can call <a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a97af7156e38c29225534bacdeefe9408">UnloadServable()</a> on it, which will make it unavailable to serve, then unload the servable.</p>
<p>Servables are retained until <a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a3209cd82cbb5eac79bc3238b3c6bec43">StopManagingServable()</a> is called. This allows a higher level manager with more information to decide when it's safe to forget about a servable.</p>
<p><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html">BasicManager</a> tracks the resources (e.g. RAM) used by loaded servables, and only allows loading new servables that fit within the overall resource pool.</p>
<p><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html">BasicManager</a> can be configured to use a thread-pool to do it's load and unloads. This makes the <a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a09e87e3b0bc3410a78db3439ff0fb9bb">LoadServable()</a> and <a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a97af7156e38c29225534bacdeefe9408">UnloadServable()</a> methods schedule the load/unloads rather than executing them synchronously. If there are more pending load/unloads than threads in the thread pool, they are processed in FIFO order.</p>
<p>In the presence of loaders that over-estimate their servables' resource needs and/or only bind their servables' resources to device instances, load/unload concurrency can be reduced below the thread-pool size. That is because we may have to wait for one servable's load/unload to finish to pin down the resource availability for loading another servable.</p>
<p>REQUIRES:</p><ol type="1">
<li>Order of method calls - <a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#ac2759caea67d3d37b9dba31589f9ef1d">ManageServable()</a> (and variants) -&gt; <a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a09e87e3b0bc3410a78db3439ff0fb9bb">LoadServable()</a> -&gt; <a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a97af7156e38c29225534bacdeefe9408">UnloadServable()</a> -&gt; <a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a3209cd82cbb5eac79bc3238b3c6bec43">StopManagingServable()</a>.</li>
<li>Do not schedule concurrent load and unloads of the same servable.</li>
<li>Do not call load or unload multiple times on the same servable.</li>
</ol>
<p>This class is thread-safe.</p>
<p>Example usage: </p><pre class="fragment">const ServableId id = {kServableName, 0};
std::unique_ptr&amp;lt;Loader&gt; loader = ...;
...
BasicManager manager;
TF_CHECK_OK(manager.ManageServable(
  CreateServableData(id, std::move(loader))));
TF_CHECK_OK(manager.LoadServable(id));

...
TF_CHECK_OK(manager.GetServableHandle(
    ServableRequest::Latest(kServableName), &amp;handle));
...

TF_CHECK_OK(manager.UnloadServable(id));
TF_CHECK_OK(manager.StopManagingServable(id)); 
</pre> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8ee7a19d059b362c0702686d981bf5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee7a19d059b362c0702686d981bf5fc">&#9670;&nbsp;</a></span>DoneCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a8ee7a19d059b362c0702686d981bf5fc">tensorflow::serving::BasicManager::DoneCallback</a> =  std::function&lt;void(const Status&amp; status)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback called at the end of {Load,Unload}Servable(). We pass in the status of the operation to the callback. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a492123b8bb97709184ddb57772e3ccf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492123b8bb97709184ddb57772e3ccf3">&#9670;&nbsp;</a></span>~BasicManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tensorflow::serving::BasicManager::~BasicManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If configured to use a load/unload thread-pool, waits until all scheduled loads and unloads have finished and then destroys the set of threads. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a84dca5ec1ecc28421d5ab020beac2ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84dca5ec1ecc28421d5ab020beac2ee3">&#9670;&nbsp;</a></span>CancelLoadServableRetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tensorflow::serving::BasicManager::CancelLoadServableRetry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancels retrying the servable load during <a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a09e87e3b0bc3410a78db3439ff0fb9bb">LoadServable()</a> by replacing the <a class="el" href="classtensorflow_1_1serving_1_1LoaderHarness.html#ae344a05f0ae81c0f589daaa737223435" title="Returns true if the servable should be retried.">LoaderHarness::should_retry</a> with a function that always returns false. Does nothing if the servable isn't managed.</p>
<p>If the retries are cancelled, the servable goes into a state dependent on the last Load() called on it. If the last Load() was successful, it will be in state kReady, else in kError. </p>

</div>
</div>
<a id="a99dbea960f6d47461dbfca5bfa149335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99dbea960f6d47461dbfca5bfa149335">&#9670;&nbsp;</a></span>GetAdditionalServableState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * tensorflow::serving::BasicManager::GetAdditionalServableState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the additional state for the servable. Returns nullptr if there is no additional state setup or if there is a type mismatch between what was setup and what is being asked for.</dd></dl>
<p>REQUIRES: This manager should have been managing this servable already, else we return nullptr. </p>

</div>
</div>
<a id="afbdc3d0ed83559c7d8b3b0092194ead6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdc3d0ed83559c7d8b3b0092194ead6">&#9670;&nbsp;</a></span>GetManagedServableNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; string &gt; tensorflow::serving::BasicManager::GetManagedServableNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the names of all the servables managed by this manager. The names will be duplicate-free and not in any particular order. </dd></dl>

</div>
</div>
<a id="af681f56bbef07ab201f25c0097f73e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af681f56bbef07ab201f25c0097f73e75">&#9670;&nbsp;</a></span>GetManagedServableStateSnapshot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">absl::optional&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableStateSnapshot.html">ServableStateSnapshot</a>&lt; T &gt; &gt; tensorflow::serving::BasicManager::GetManagedServableStateSnapshot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the state snapshot of a particular servable-id managed by this manager if available.</dd></dl>
<p>REQUIRES: This manager should have been managing this servable already, else we return nullopt. </p>

</div>
</div>
<a id="a31716665d8df8451d379363309dac826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31716665d8df8451d379363309dac826">&#9670;&nbsp;</a></span>GetManagedServableStateSnapshots()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableStateSnapshot.html">ServableStateSnapshot</a>&lt; T &gt; &gt; tensorflow::serving::BasicManager::GetManagedServableStateSnapshots </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>servable_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the state snapshots of all the servables of a particular stream, managed by this manager.</dd></dl>
<p>T is the additional-state type, if any. </p>

</div>
</div>
<a id="a3c004d32952596c1f5759b1cfcc3c639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c004d32952596c1f5759b1cfcc3c639">&#9670;&nbsp;</a></span>ListAvailableServableIds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &gt; tensorflow::serving::BasicManager::ListAvailableServableIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a list of all available servable ids, i.e. each of these can be retrieved using GetServableHandle. </p>

<p>Implements <a class="el" href="classtensorflow_1_1serving_1_1Manager.html#a10694eb8c3e845e4738788092057b7ef">tensorflow::serving::Manager</a>.</p>

</div>
</div>
<a id="a09e87e3b0bc3410a78db3439ff0fb9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e87e3b0bc3410a78db3439ff0fb9bb">&#9670;&nbsp;</a></span>LoadServable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tensorflow::serving::BasicManager::LoadServable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a8ee7a19d059b362c0702686d981bf5fc">DoneCallback</a>&#160;</td>
          <td class="paramname"><em>done_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads the servable with this id, and updates the serving map too. Calls <em>done_callback</em> with ok iff the servable was loaded successfully, else returns an error status.</p>
<p>If using a thread-pool, this method transitions the servable harness to kLoading state, schedules the load and returns, otherwise it completes the load before returning.</p>
<p>REQUIRES: This manager should have been managing this servable already, for it to be loaded, else we call <em>done_callback</em> with an error status. Do not call this multiple times on the same servable. Only one of those will succeed and the rest will fail with an error status. </p>

</div>
</div>
<a id="ac2759caea67d3d37b9dba31589f9ef1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2759caea67d3d37b9dba31589f9ef1d">&#9670;&nbsp;</a></span>ManageServable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Status tensorflow::serving::BasicManager::ManageServable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorflow_1_1serving_1_1ServableData.html">ServableData</a>&lt; std::unique_ptr&lt; <a class="el" href="classtensorflow_1_1serving_1_1Loader.html">Loader</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>servable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts managing the servable.</p>
<p>Returns an error if given a servable that is already being managed.</p>
<p>If <em>servable</em> is in an error state, this method does <b>not</b> return an error. Instead, the manager accepts the servable, puts it in state kError (with a notification sent to the event bus), and then immediately stops managing it. This behavior facilitates uniform handling of errors that occur in sources (e.g. invalid file path to servable data) and ones that occur in the manager (e.g. insufficient resources to load servable). </p>

</div>
</div>
<a id="a72406e3aedfa0084e24f2bd8ec7efdcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72406e3aedfa0084e24f2bd8ec7efdcc">&#9670;&nbsp;</a></span>ManageServableWithAdditionalState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Status tensorflow::serving::BasicManager::ManageServableWithAdditionalState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtensorflow_1_1serving_1_1ServableData.html">ServableData</a>&lt; std::unique_ptr&lt; <a class="el" href="classtensorflow_1_1serving_1_1Loader.html">Loader</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>servable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>additional_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to the above method, but callers, usually other managers built on top of this one, can associate additional state with the servable. Additional state may be ACL or lifetime metadata for that servable. The ownership of the state is transferred to this class. </p>

</div>
</div>
<a id="a3209cd82cbb5eac79bc3238b3c6bec43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3209cd82cbb5eac79bc3238b3c6bec43">&#9670;&nbsp;</a></span>StopManagingServable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Status tensorflow::serving::BasicManager::StopManagingServable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells the manager to stop managing this servable. Requires that the servable is currently being managed and that its state is one of {kNew, kError, kDisabled}. </p>

</div>
</div>
<a id="a97af7156e38c29225534bacdeefe9408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97af7156e38c29225534bacdeefe9408">&#9670;&nbsp;</a></span>UnloadServable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tensorflow::serving::BasicManager::UnloadServable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtensorflow_1_1serving_1_1BasicManager.html#a8ee7a19d059b362c0702686d981bf5fc">DoneCallback</a>&#160;</td>
          <td class="paramname"><em>done_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unloads the servable with this id, and updates the serving map too. Calls <em>done_callback</em> with ok iff the servable was unloaded successfully, else returns an error status.</p>
<p>If using a thread-pool, this method transitions the servable harness to kQuiescing state, schedules the unload and returns, otherwise it completes the unload before returning.</p>
<p>REQUIRES: This manager should have loaded and made this servable available, for it to be unloaded, else calls <em>done_callback</em> with an error status. Do not call this multiple times on the same servable. Only one of those will succeed and the rest will fail with an error status. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>tensorflow_serving/core/<a class="el" href="basic__manager_8h_source.html">basic_manager.h</a></li>
<li>tensorflow_serving/core/basic_manager.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
