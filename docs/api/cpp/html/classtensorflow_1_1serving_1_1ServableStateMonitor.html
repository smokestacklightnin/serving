<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: tensorflow::serving::ServableStateMonitor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tensorflow</b></li><li class="navelem"><b>serving</b></li><li class="navelem"><a class="el" href="classtensorflow_1_1serving_1_1ServableStateMonitor.html">ServableStateMonitor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtensorflow_1_1serving_1_1ServableStateMonitor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tensorflow::serving::ServableStateMonitor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="servable__state__monitor_8h_source.html">servable_state_monitor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorflow_1_1serving_1_1ServableStateMonitor_1_1Options.html">Options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtensorflow_1_1serving_1_1ServableStateMonitor_1_1ServableStateAndTime.html">ServableStateAndTime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5ef18d6969478a087530f5b77e0bd2f1"><td class="memItemLeft" align="right" valign="top"><a id="a5ef18d6969478a087530f5b77e0bd2f1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ServableName</b> = string</td></tr>
<tr class="separator:a5ef18d6969478a087530f5b77e0bd2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd5912de4ba934c46ad82db1c525ce3"><td class="memItemLeft" align="right" valign="top"><a id="aacd5912de4ba934c46ad82db1c525ce3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Version</b> = int64</td></tr>
<tr class="separator:aacd5912de4ba934c46ad82db1c525ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8010e4b3453ae200256f3d56dd8f755e"><td class="memItemLeft" align="right" valign="top"><a id="a8010e4b3453ae200256f3d56dd8f755e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VersionMap</b> = std::map&lt; Version, <a class="el" href="structtensorflow_1_1serving_1_1ServableStateMonitor_1_1ServableStateAndTime.html">ServableStateAndTime</a>, std::greater&lt; Version &gt; &gt;</td></tr>
<tr class="separator:a8010e4b3453ae200256f3d56dd8f755e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d0ee57a6dcd59e82e460c0d17a2604"><td class="memItemLeft" align="right" valign="top"><a id="a61d0ee57a6dcd59e82e460c0d17a2604"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ServableMap</b> = std::map&lt; ServableName, VersionMap &gt;</td></tr>
<tr class="separator:a61d0ee57a6dcd59e82e460c0d17a2604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d43d766bb8316983316896f258498e"><td class="memItemLeft" align="right" valign="top"><a id="a58d43d766bb8316983316896f258498e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ServableSet</b> = std::set&lt; ServableName &gt;</td></tr>
<tr class="separator:a58d43d766bb8316983316896f258498e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbb131b4d7c6f036da6e3ebed3b6ad1"><td class="memItemLeft" align="right" valign="top"><a id="a6dbb131b4d7c6f036da6e3ebed3b6ad1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BoundedLog</b> = std::deque&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableStateMonitor_1_1ServableStateAndTime.html">ServableStateAndTime</a> &gt;</td></tr>
<tr class="separator:a6dbb131b4d7c6f036da6e3ebed3b6ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b64d18d981941012439766e57bd8d66"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1ServableStateMonitor.html#a6b64d18d981941012439766e57bd8d66">ServableStateNotifierFn</a> = std::function&lt; void(bool reached_goal_state, const std::map&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a>, ServableState::ManagerState &gt; &amp;states_reached)&gt;</td></tr>
<tr class="separator:a6b64d18d981941012439766e57bd8d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c97d1fd2318e71b83eac646e27599c9"><td class="memItemLeft" align="right" valign="top"><a id="a4c97d1fd2318e71b83eac646e27599c9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NotifyFn</b> = std::function&lt; void(const <a class="el" href="structtensorflow_1_1serving_1_1ServableState.html">ServableState</a> &amp;)&gt;</td></tr>
<tr class="separator:a4c97d1fd2318e71b83eac646e27599c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a85cf3611dfc401b031f92c0cfa353bfd"><td class="memItemLeft" align="right" valign="top"><a id="a85cf3611dfc401b031f92c0cfa353bfd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ServableStateMonitor</b> (<a class="el" href="classtensorflow_1_1serving_1_1EventBus.html">EventBus</a>&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableState.html">ServableState</a> &gt; *bus, const <a class="el" href="structtensorflow_1_1serving_1_1ServableStateMonitor_1_1Options.html">Options</a> &amp;options=<a class="el" href="structtensorflow_1_1serving_1_1ServableStateMonitor_1_1Options.html">Options</a>())</td></tr>
<tr class="separator:a85cf3611dfc401b031f92c0cfa353bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa6dd1536bbb85a55b3e41c1d2577d1"><td class="memItemLeft" align="right" valign="top">absl::optional&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableState.html">ServableState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1ServableStateMonitor.html#a8fa6dd1536bbb85a55b3e41c1d2577d1">GetState</a> (const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;servable_id) const TF_LOCKS_EXCLUDED(mu_)</td></tr>
<tr class="separator:a8fa6dd1536bbb85a55b3e41c1d2577d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff54ab2471885168dba0b1a05be7bea"><td class="memItemLeft" align="right" valign="top">absl::optional&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableStateMonitor_1_1ServableStateAndTime.html">ServableStateAndTime</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1ServableStateMonitor.html#a8ff54ab2471885168dba0b1a05be7bea">GetStateAndTime</a> (const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;servable_id) const TF_LOCKS_EXCLUDED(mu_)</td></tr>
<tr class="separator:a8ff54ab2471885168dba0b1a05be7bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501ef561e30709fe17f10c913d34bb1e"><td class="memItemLeft" align="right" valign="top">VersionMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1ServableStateMonitor.html#a501ef561e30709fe17f10c913d34bb1e">GetVersionStates</a> (const string &amp;servable_name) const TF_LOCKS_EXCLUDED(mu_)</td></tr>
<tr class="separator:a501ef561e30709fe17f10c913d34bb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3c1c27b6b7c0e8ef9a42039ede74cc"><td class="memItemLeft" align="right" valign="top"><a id="abc3c1c27b6b7c0e8ef9a42039ede74cc"></a>
ServableMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1ServableStateMonitor.html#abc3c1c27b6b7c0e8ef9a42039ede74cc">GetAllServableStates</a> () const TF_LOCKS_EXCLUDED(mu_)</td></tr>
<tr class="memdesc:abc3c1c27b6b7c0e8ef9a42039ede74cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current states of all tracked versions of all servables. <br /></td></tr>
<tr class="separator:abc3c1c27b6b7c0e8ef9a42039ede74cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522166e0255c93e87a6d63c3d17e3f38"><td class="memItemLeft" align="right" valign="top">ServableMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1ServableStateMonitor.html#a522166e0255c93e87a6d63c3d17e3f38">GetLiveServableStates</a> () const TF_LOCKS_EXCLUDED(mu_)</td></tr>
<tr class="separator:a522166e0255c93e87a6d63c3d17e3f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ad2a50b7fa7b695885fe913b70b029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1ServableStateMonitor.html#ae3ad2a50b7fa7b695885fe913b70b029">ForgetUnloadedServableStates</a> () TF_LOCKS_EXCLUDED(mu_)</td></tr>
<tr class="separator:ae3ad2a50b7fa7b695885fe913b70b029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4623ec7d0e8c756bfe0603d879304c7"><td class="memItemLeft" align="right" valign="top"><a id="af4623ec7d0e8c756bfe0603d879304c7"></a>
ServableSet&#160;</td><td class="memItemRight" valign="bottom"><b>GetAvailableServableStates</b> () const TF_LOCKS_EXCLUDED(mu_)</td></tr>
<tr class="separator:af4623ec7d0e8c756bfe0603d879304c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afc57f0eb671a3c3342c7dd71a9d6a7"><td class="memItemLeft" align="right" valign="top"><a id="a2afc57f0eb671a3c3342c7dd71a9d6a7"></a>
BoundedLog&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1ServableStateMonitor.html#a2afc57f0eb671a3c3342c7dd71a9d6a7">GetBoundedLog</a> () const TF_LOCKS_EXCLUDED(mu_)</td></tr>
<tr class="memdesc:a2afc57f0eb671a3c3342c7dd71a9d6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current bounded log of handled servable state events. <br /></td></tr>
<tr class="separator:a2afc57f0eb671a3c3342c7dd71a9d6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b073bf82b07c224227e1efa5d44603"><td class="memItemLeft" align="right" valign="top"><a id="a06b073bf82b07c224227e1efa5d44603"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>NotifyWhenServablesReachState</b> (const std::vector&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableRequest.html">ServableRequest</a> &gt; &amp;servables, ServableState::ManagerState goal_state, const <a class="el" href="classtensorflow_1_1serving_1_1ServableStateMonitor.html#a6b64d18d981941012439766e57bd8d66">ServableStateNotifierFn</a> &amp;notifier_fn) TF_LOCKS_EXCLUDED(mu_)</td></tr>
<tr class="separator:a06b073bf82b07c224227e1efa5d44603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9579ee04bf76fa627d65d9cbbb7ccb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtensorflow_1_1serving_1_1ServableStateMonitor.html#aa9579ee04bf76fa627d65d9cbbb7ccb7">WaitUntilServablesReachStateWithTimeout</a> (const std::vector&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableRequest.html">ServableRequest</a> &gt; &amp;servables, ServableState::ManagerState goal_state, absl::Duration timeout, std::map&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a>, ServableState::ManagerState &gt; *states_reached=nullptr) TF_LOCKS_EXCLUDED(mu_) TF_MUST_USE_RESULT</td></tr>
<tr class="separator:aa9579ee04bf76fa627d65d9cbbb7ccb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e01409c4f3d16789ae42ba9b5fd0b12"><td class="memItemLeft" align="right" valign="top"><a id="a3e01409c4f3d16789ae42ba9b5fd0b12"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>WaitUntilServablesReachState</b> (const std::vector&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableRequest.html">ServableRequest</a> &gt; &amp;servables, ServableState::ManagerState goal_state, std::map&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a>, ServableState::ManagerState &gt; *states_reached=nullptr) TF_MUST_USE_RESULT</td></tr>
<tr class="separator:a3e01409c4f3d16789ae42ba9b5fd0b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8b172f93c8e74937c4594dd332c154"><td class="memItemLeft" align="right" valign="top"><a id="a6d8b172f93c8e74937c4594dd332c154"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Notify</b> (const NotifyFn &amp;notify_fn) TF_LOCKS_EXCLUDED(notify_mu_)</td></tr>
<tr class="separator:a6d8b172f93c8e74937c4594dd332c154"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A utility that listens to an <a class="el" href="classtensorflow_1_1serving_1_1EventBus.html">EventBus</a>&amp;lt;<a class="el" href="structtensorflow_1_1serving_1_1ServableState.html">ServableState</a>&gt;, and keeps track of the state of each servable mentioned on the bus. The intended use case is to track the states of servables in a <a class="el" href="classtensorflow_1_1serving_1_1Manager.html">Manager</a>.</p>
<p>Offers an interface for querying the servable states. It may be useful as the basis for dashboards, as well as for testing a manager.</p>
<p>IMPORTANT: You must create this monitor before arranging for events to be published on the event bus, e.g. giving the event bus to a <a class="el" href="classtensorflow_1_1serving_1_1Manager.html">Manager</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6b64d18d981941012439766e57bd8d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b64d18d981941012439766e57bd8d66">&#9670;&nbsp;</a></span>ServableStateNotifierFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtensorflow_1_1serving_1_1ServableStateMonitor.html#a6b64d18d981941012439766e57bd8d66">tensorflow::serving::ServableStateMonitor::ServableStateNotifierFn</a> =  std::function&lt;void( bool reached_goal_state, const std::map&lt;<a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a>, ServableState::ManagerState&gt;&amp; states_reached)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notifies when all of the servables have reached the 'goal_state'.</p>
<p>Servables can be specified in two ways:</p><ol type="1">
<li>As specific versions of a servable stream name. In this case, we check whether the specific version has reached the 'goal_state' or kEnd.</li>
<li>As latest versions, in which case any version for a servable stream name will be matched against the 'goal_state' or kEnd.</li>
</ol>
<p>We call the 'notifier_fn' when both conditions are true -</p><ol type="1">
<li>All of the specific servable requests have either reached the 'goal_state' or kEnd.</li>
<li>All of the latest servable requests have reached 'goal_state' or kEnd. The 'notifier_fn' will be called only once, and not repeatedly.</li>
</ol>
<p>The 'reached_goal_state' argument is set as true iff all of the specific servables have reached 'goal_state'. So callers should verify that 'reached_goal_state' is true in the 'notifier_fn'.</p>
<p>The 'states_reached' argument is populated with the servable's id and the state it reached. The state would be 'goal_state' if 'reached_goal_state' is true, else it will contain one or more servables in kEnd state. For latest servable requests, the servable id will be the id of the servable in the stream which reached the state. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae3ad2a50b7fa7b695885fe913b70b029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ad2a50b7fa7b695885fe913b70b029">&#9670;&nbsp;</a></span>ForgetUnloadedServableStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tensorflow::serving::ServableStateMonitor::ForgetUnloadedServableStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all servable versions from the ServableMap whose states have transitioned to kEnd. </p>

</div>
</div>
<a id="a522166e0255c93e87a6d63c3d17e3f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522166e0255c93e87a6d63c3d17e3f38">&#9670;&nbsp;</a></span>GetLiveServableStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ServableStateMonitor::ServableMap tensorflow::serving::ServableStateMonitor::GetLiveServableStates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current states of all versions of all servables which have not transitioned to state ServableState::ManagerState::kEnd. </p>

</div>
</div>
<a id="a8fa6dd1536bbb85a55b3e41c1d2577d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa6dd1536bbb85a55b3e41c1d2577d1">&#9670;&nbsp;</a></span>GetState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::optional&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableState.html">ServableState</a> &gt; tensorflow::serving::ServableStateMonitor::GetState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;&#160;</td>
          <td class="paramname"><em>servable_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current state of one servable, or nullopt if that servable is not being tracked. </p>

</div>
</div>
<a id="a8ff54ab2471885168dba0b1a05be7bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff54ab2471885168dba0b1a05be7bea">&#9670;&nbsp;</a></span>GetStateAndTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">absl::optional&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableStateMonitor_1_1ServableStateAndTime.html">ServableStateMonitor::ServableStateAndTime</a> &gt; tensorflow::serving::ServableStateMonitor::GetStateAndTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a> &amp;&#160;</td>
          <td class="paramname"><em>servable_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current state and time of one servable, or nullopt if that servable is not being tracked. </p>

</div>
</div>
<a id="a501ef561e30709fe17f10c913d34bb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501ef561e30709fe17f10c913d34bb1e">&#9670;&nbsp;</a></span>GetVersionStates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ServableStateMonitor::VersionMap tensorflow::serving::ServableStateMonitor::GetVersionStates </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>servable_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current states of all tracked versions of the given servable, if any. </p>

</div>
</div>
<a id="aa9579ee04bf76fa627d65d9cbbb7ccb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9579ee04bf76fa627d65d9cbbb7ccb7">&#9670;&nbsp;</a></span>WaitUntilServablesReachStateWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tensorflow::serving::ServableStateMonitor::WaitUntilServablesReachStateWithTimeout </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableRequest.html">ServableRequest</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>servables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ServableState::ManagerState&#160;</td>
          <td class="paramname"><em>goal_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Duration&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="structtensorflow_1_1serving_1_1ServableId.html">ServableId</a>, ServableState::ManagerState &gt; *&#160;</td>
          <td class="paramname"><em>states_reached</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to NotifyWhenServablesReachState(...), but instead of notifying, we wait until the 'goal_state' or kEnd is reached.</p>
<p>To understand the return value and the return parameter 'states_reached', please read the documentation on NotifyWhenServablesReachState(...). WaitUntilServablesReachStateWithTimeout and WaitUntilServablesReachState perform the same function, but the former has a timeout while the latter waits indefinitely. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>tensorflow_serving/core/<a class="el" href="servable__state__monitor_8h_source.html">servable_state_monitor.h</a></li>
<li>tensorflow_serving/core/servable_state_monitor.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
